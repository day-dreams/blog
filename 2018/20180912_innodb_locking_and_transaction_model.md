# InnoDB锁机制与事务模型

这篇文章将详细说明Innodb锁机制，以及如何影响到事务模型。主要内容源于[MySQL5.7 InnoDB Locking and Transaction Model](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html)
如何条件允许，建议直接看官方文档甚至是源码分析，而不是来这里看翻译。

## InnoDB Locking

InnoDB为了支持并发，使用了很多种类的锁，这一节简要分析这些锁。

* Shared and Exclusive Locks，共享锁和互斥锁

    这两种锁是行级锁，用于对一条记录加锁。事务要读取一行记录时，需要加S锁;事务更新或者删除一行记录时，需要加X锁。允许多个事务同时对同行记录加S锁，这样它们都可以读取这行记录;但是X锁是互斥的，只有一个事务可以对一行记录加X锁，并且不允许任何记录对它加S或X锁。

* Intention Locks，意向锁

    S和X锁关注的是行级别的并发，意向锁关注的是表级别。在意向锁的机制下，允许表级别锁和行级别锁同时存在。意向锁说明的是，事务**将来**会对表里的某行加S锁或者X锁。意向锁分为**Intention shared lock(IS)** 和 **Intention exclusive lock(IX)**，这里不再详细说明。  

     引入意向锁后，如果事务想要读表里的某一行记录，在获得记录的S锁之前，必须先获得表的IS锁（或者更强的锁）;如果事务要写表里的某行记录，在获得该记录的X锁之前，必须先获得表的IX锁。

    意向锁的获得方法一般是通过**LOCK TABLE ... READ** 和 **LOCK TABLE ... WRITE**。前者对表加IS锁，其他事务也可以加IS锁从而读取记录;后者对表加IX锁，当前事务可以读记录或者写记录，但其他事务无法再获得IS和IX锁，不能对表进行任何操作。

* Record Locks，记录锁

    记录锁是针对一条索引记录的。注意，一条索引记录并不代表一行数据。从记录锁开始，后面介绍的锁就不太涉及S和X的概念了，所以不要总是想着“记录所到底是X锁还是S锁“这种问题了。

* Gap Locks，间隙锁

    间隙锁用于锁住索引记录之间的间隙。间隙锁不允许其他事务，向间隙中插入任何数据。
    如果一条SQL只是使用唯一索引作为搜索条件，不会触发间隙所，而仅仅是触发记录锁。比如“SELECT * FROM child WHERE id=100;”，如果id是唯一索引，这条SQL只会对100这个唯一索引加锁;如果id不是索引，或者id不是唯一索引，这条SQL将对100和100之前的那个key之间的范围，加上间隙锁。

    注意，间隙锁没有必要区分是X锁还是S锁，因为它的功能只有一个：防止其他事务插入数据。

* Next-Key Locks

    Next-key Locks是Record Lock和Gap Lock的结合，针对一条索引记录以及它之前的间隙。注意，这个锁是区分X和S的。
当InnoDB搜索一张表的索引时，会使用Next-Key锁，避免发生幻读。后面会详细解释。

* Insert Intention Locks，插入意向锁

    这个锁也是一种间隙锁，一般在INSERT语句执行插入动作之前获得。与一般间隙锁不同的是，它允许多个事务对一个间隙加插入意向锁，只要事务插入的不是同一条记录。

    这个锁同时也是一个意向锁，获得了插入意向锁不代表可以立即插入，事务必须继续获得相关的X锁，才能最终执行插入动作。

* AUTO-INC Locks，自增锁

    这个锁用于具有自增字段的插入场景。不同事务必须对当前的自增键有一致的认知，不能各自看到不同的自增值。

## InnoDB Transaction Model

锁是实现事务的关键工具之一，下面开始介绍事务模型。

### 隔离级别

InnoDB支持四种隔离级别，分别是对性能和ACID不同程度的权衡。不同的隔离级别具有不同的锁策略，下面一一介绍。再次说明，如果条件允许，请直接去看官方文档，这比看翻译来的更加直接。

* 可重复读

    InnoDB默认设置为可重复读。在这个级别内，所有普通的SELECT操作（不带有FOR UPDATE等语法）都不受锁机制控制，而是直接采取一致性读机制，也就是多版本控制，每个事务看到的都是已经提交的、最新的记录。

   对于Locking Reads（带有FOR UPDATE、LOCK IN SHARE MODE的SELECT语句）、UPDATE、DELETE语句，采取锁机制，并且根据语句是否使用了唯一索引而不同：
    * 如果语句的搜索条件只包含一个唯一索引，InnoDB只锁住匹配的记录，而不锁匹配记录前面的间隙。 
    * 其他情况下，InnoDB锁住扫描过的每个索引范围，使用间隙锁或者Next-Key锁。 

    在这个级别下，无论记录是不是跟搜索条件匹配，锁不会被立即释放，会统一等到事务提交或回滚时才释放。
* 读已提交

   这个级别比可重复读要低，提供的一致性保证有所松动，但也带来了更好的性能。 

    首先，所有普通SELECT仍然走多版本控制机制。

    对于Locking Reads（带有FOR UPDATE、LOCK IN SHARE                                                             ↪MODE的SELECT语句）、UPDATE、DELETE语句，InnoDB仍然会加锁。但只对记录本身加锁，不对范围加锁，也就是不加间隙锁。只在设计到外键时，才使用间隙锁。这里也能看到，外键会带来额外的性能开销。

    由于释放锁很快，不匹配的记录会被直接释放锁，读已提交无法避免不可重复读问题。

    这个级别下，InnoDB扫描记录时，不会一直保持锁。在UPDATE和DELETE语句执行时，每次扫描一个记录，Innodb先获得这个记录的互斥锁，然后比较：如果搜索条件成功匹配，更新这个记录，并保持锁;否则，直接释放互斥锁。这将允许其他事务修改这张表，更宽松的一致性保证也体现于此。而如果这个记录已经被其他事务加上了互斥锁，Innodb首先参考记录的历史最新版本（类似于MVCC），如果没有匹配，认为这条记录在当前事务中不能匹配上搜索条件，于是放弃修改直接扫描下一个记录;如果匹配了，当前事务不得不陷入等待，直到获得自己想加的锁。

上面两种级别的不同主要在于：释放锁的时机、加锁的范围。**官方文档中给出了两个事务的例子，详细说明了这两种级别的不同，强烈推荐去看看文档。**

* 读未提交

    这个级别更弱，具有脏读、不可重复读、幻读问题。估计不会有人使用这种隔离级别，官方文档也没有太多的说明，这里也不再继续研究了。

* 可串行化

    这个级别比以上三种级别都强。这个级别里，不再有MVCC，普通的SELECT会被隐式加上FOR SHARE MODE，从而加上潜在的IS和S锁。这真正保证了并发事务的有序执行，这时的并发如果按照先后顺序，串行执行，效果是一样的。脏读、不可重复读、幻读都不存在。

### 一致性读

一致性读和多版本并发控制有关，大致原理很简单，这里不做了解了。

### Locking Reads

Locking Reads分为两种： **SELECT ... FOR UPDATE** 和 **SELECT ... LOCK IN SHARE MODE** 。前者加互斥锁，后者加共享锁。

如果我们的DB操作具有Parent-Child的形式，比如根据一张表里的某个记录，去另一张表里查找关联记录并修改。这里存在因果关系，只有先查找到的记录符合条件，才能去查找、修改关联记录。我们希望因和果是原子性的，绝不允许在结果发生之前，有其他事务执行潜在的干扰动作。通过Locking Reads，可以很好的保证因果的原子性。

## Questions

* 为什么允许不同事务对一个间隙加互相冲突的间隙锁？
* Locking Reads有什么用？
* 四种隔离级别各自有着什么样的问题？锁机制有什么不同？




